#!/bin/bash
# Filename:      grml-live
# Purpose:       build process script for generating a (grml based) Linux Live-ISO
# Authors:       Grml Team (see https://grml.org/)
# Bug-Reports:   see http://grml.org/bugs/
# License:       This file is licensed under the GPL v2 or any later version.
################################################################################

# some misc and global stuff {{{
export LANG=C
export LC_ALL=C

# avoid leaking into chroots
unset TMPDIR

# define function getfilesize before "set -e"
if stat --help >/dev/null 2>&1; then
  getfilesize='stat -c %s'  # GNU stat
else
  getfilesize='stat -f %z'  # BSD stat
fi

# exit on any error:
# disable for now since it seems to cause some problems
# set -e

# The line following this line is patched by debian/rules.
GRML_LIVE_VERSION='***UNRELEASED***'

# global variables
PN=$(basename "$0")
CMDLINE="$0 $*"
GRML_LIVE_INSTALL_PREFIX=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
if [ -e "${GRML_LIVE_INSTALL_PREFIX}"/usr/lib/grml-live ]; then
    # assume source checkout
    GRML_LIVE_LIB_DIR="${GRML_LIVE_INSTALL_PREFIX}"/usr/lib/grml-live
else
    GRML_LIVE_INSTALL_PREFIX=${GRML_LIVE_INSTALL_PREFIX}/../
    GRML_LIVE_LIB_DIR=${GRML_LIVE_INSTALL_PREFIX}/lib/grml-live
fi
# }}}

# usage information {{{
usage()
{
  echo "
$PN - build process script for generating a (grml based) Linux Live-ISO

Usage: $PN [options, see as follows]

   -a <architecture>       architecture; available values: i386, amd64 + arm64
   -A                      clean build directories before and after running
   -b                      build the ISO without updating the chroot
   -B                      build the ISO without touching the chroot (skips cleanup)
   -c <classe[s]>          classes to be used for building the ISO
   -C <configfile>         configuration file for grml-live
   -d <date>               use specified date instead of build time as date of release
   -D <configdir>          use specified configuration directory instead of /usr/share/grml-live/config
   -e <iso_name>           extract ISO and squashfs contents from iso_name
   -F                      force execution without prompting
   -g <grml_name>          set the grml flavour name
   -h                      display short usage information and exit
   -i <iso_name>           name of ISO
   -I <src_directory>      directory which provides files that should become
                           part of the chroot/ISO
   -n                      skip generation of ISO
   -N                      bootstrap (build chroot) only, do not create files for ISO
   -o <output_directory>   main output directory of the build process
   -q                      skip mksquashfs
   -Q                      skip netboot package build
   -r <release_name>       release name
   -s <suite>              Debian suite/release, like: stable, testing, unstable
   -S <script_directory>   place of scripts (defaults to /usr/share/grml-live/scripts)
   -t <template_directory> place of the templates
   -u                      update existing chroot instead of rebuilding it from scratch
   -U <username>           arrange output to be owned by specified username
   -v <version_number>     specify version number of the release
   -V                      increase verbosity in the build process
   -w <date>               wayback machine, build system using Debian archives
                           from specified date
   -z                      use ZLIB instead of LZMA/XZ compression

Usage examples:

    $PN
    $PN -c GRMLBASE,GRML_FULL,AMD64 -o /dev/shm/grml
    $PN -c GRMLBASE,GRML_FULL,AMD64 -i grml_0.0-1.iso -v 0.0-1
    $PN -c GRMLBASE,GRML_FULL,AMD64 -s stable -V -r 'grml-ftw'

More details: man grml-live + /usr/share/doc/grml-live/grml-live.html
              http://grml.org/grml-live/

Please send your bug reports and feedback to the grml-team: http://grml.org/bugs/
"
   [ "$(id -u 2>/dev/null)" != 0 ] && echo "Please notice that this script requires root permissions."
}

# make sure it's possible to get usage information without being
# root or actually executing the script
if [ "$1" = '-h' ] || [ "$1" = '--help' ] ; then
   usage
   exit 0
fi
# }}}

# some runtime checks {{{
# we need root permissions for the build-process:
if [ "$(id -u 2>/dev/null)" != 0 ] ; then
   echo "Error: please run this script with uid 0 (root)." >&2
   exit 1
fi

# lsb-functions and configuration stuff {{{
# make sure they are not set by default
FORCE=''
UPDATE=''
BUILD_ONLY=''
BUILD_DIRTY=''
BOOTSTRAP_ONLY=''
HOSTNAME=''
USERNAME=''
CONFIGDUMP=''
FAI_PROGRAM=$GRML_LIVE_LIB_DIR/minifai
# }}}

# don't use colors/escape sequences
if [ -r /lib/lsb/init-functions ] ; then
  # shellcheck source=/dev/null
  . /lib/lsb/init-functions
  # shellcheck disable=SC2034
  ! log_use_fancy_output && NOCOLORS=true
fi

if [ -r /etc/grml/lsb-functions ] ; then
   # shellcheck source=/dev/null
   . /etc/grml/lsb-functions
else
   einfo()  { echo "  [*] $*" ;}
   eerror() { echo "  [!] $*">&2 ;}
   ewarn()  { echo "  [x] $*" ;}
   eend()   { return 0 ;}
   eindent()  { return 0 ;}
   eoutdent() { return 0 ;}
fi

# source main configuration file:
[ -z "$LIVE_CONF" ] && LIVE_CONF='/etc/grml/grml-live.conf'
if ! [ -r "$LIVE_CONF" ] ; then
  ewarn "Configuration file $LIVE_CONF can not be read, ignoring"
else
  einfo "Sourcing configuration file $LIVE_CONF"
  # shellcheck source=/dev/null
  . "$LIVE_CONF"
  eend $?
fi
# }}}

# umount all directories {{{
umount_all() {
   [ -n "$MIRROR_DIRECTORY" ] && umount "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
}
# }}}

# store logfiles {{{
store_logfiles() {
  # move minifai logs into grml_logs directory
  mkdir -p "$LOG_OUTPUT"/fai/
  cp -r "$CHROOT_OUTPUT"/grml-live/log/* "$LOG_OUTPUT"/fai/
  rm -rf "$CHROOT_OUTPUT"/grml-live/log

  # ensure files are readable.
  chmod a+rX "$LOG_OUTPUT"/fai/
}
# }}}

# clean exit {{{
bailout() {
  [ -n "$CONFIGDUMP"      ]  && rm -f  "$CONFIGDUMP"
  [ -n "$SQUASHFS_STDERR" ]  && rm -rf "$SQUASHFS_STDERR"
  umount_all
  [ -n "$1" ] && EXIT="$1" || EXIT="1"
  [ -n "$2" ] && eerror "$2">&2
  if [ -n "$CLEAN_ARTIFACTS" ]; then
    log "Cleaning up"
    einfo "Cleaning up"
    [ -n "${BUILD_OUTPUT}"  ] && [ -d "${BUILD_OUTPUT}"  ] && rm -r "${BUILD_OUTPUT}"
    [ -n "${CHROOT_OUTPUT}" ] && [ -d "${CHROOT_OUTPUT}" ] && rm -r "${CHROOT_OUTPUT}"
    eend 0
  fi

  if [ -n "$CHOWN_USER" ]; then
    log "Setting ownership"
    einfo "Setting ownership"
    [ -n "${OUTPUT}"         ] && [ -d "${OUTPUT}"         ] && chown -R "${CHOWN_USER}:" "${OUTPUT}"
    [ -n "${BUILD_OUTPUT}"   ] && [ -d "${BUILD_OUTPUT}"   ] && chown -R "${CHOWN_USER}:" "${BUILD_OUTPUT}"
    [ -n "${CHROOT_OUTPUT}"  ] && [ -d "${CHROOT_OUTPUT}"  ] && chown -R "${CHOWN_USER}:" "${CHROOT_OUTPUT}"
    [ -n "${ISO_OUTPUT}"     ] && [ -d "${ISO_OUTPUT}"     ] && chown -R "${CHOWN_USER}:" "${ISO_OUTPUT}"
    [ -n "${LOG_OUTPUT}"     ] && [ -d "${LOG_OUTPUT}"     ] && chown -R "${CHOWN_USER}:" "${LOG_OUTPUT}"
    [ -n "${NETBOOT}"        ] && [ -d "${NETBOOT}"        ] && chown -R "${CHOWN_USER}:" "${NETBOOT}"
    eend 0
  fi
  log "------------------------------------------------------------------------------"
  exit "$EXIT"
}
trap bailout 1 2 3 3 6 14 15
trap umount_all EXIT
# }}}

# some important functions {{{

# log output:
# usage: log "string to log"
log() { [ -n "$LOGFILE" ] && echo "$*" >> "$LOGFILE" ; }

# cut string at character number int = $1
# usage: cut_string 5 "1234567890" will output "12345"
cut_string() {
  [ -n "$2" ] || return 1
  echo "$2" | head -c "$1"; echo -ne "\n"
}

# append int = $1 spaces to string = $2
# usage: extend_string_end 5 "123" will output "123  "
extend_string_end() {
  [ -n "$2" ] || return 1
  local text
  text=$(echo -n "$2" | head -c "$1")
  while [ "$1" -gt "${#text}" ] ; do
    text="${text} "
  done
  echo -n "${text}"
}

# Returns success if a given class was requested.
# This is not called `ifclass`, as ifclass supports a broader syntax.
hasclass() {
  local expected_class="$1"
  case $CLASSES in *,${expected_class},*) return 0 ;; esac
  case $CLASSES in *,${expected_class}) return 0 ;; esac
  case $CLASSES in ${expected_class},*) return 0 ;; esac
  return 1
}

# Usage:
#   copy_file_logged /destination/filename /tree /src1 /src2 ...
# This copies one of the given files /src1 *or* /src2 or ..., which
# should exist inside /tree. The first matching file will be copied
# and be named /destination/filename.
# If none of the source files are found, 1 will be returned. Callers
# may opt into checking that.
copy_file_logged() {
  local dest="$1"
  shift
  local source_root="$1"
  shift
  local source

  for source in "$@" ; do
    if [ -r "${source_root}${source}" ] ; then
      log "Installing ${source} as ${dest}"
      cp "${source_root}${source}" "${dest}"
      return 0
    fi
  done
  log "Not installing ${dest}, no source files found"
  return 1
}

# replace placeholders in template files with actual information
adjust_boot_files() {
  if [ -z "$1" ] ; then
    echo "Usage: adjust_boot_files <template_file>" >&2
    exit 1
  fi

  local release_info
  if [ -n "${RELEASE_INFO:-}" ] ; then
    release_info="${RELEASE_INFO}"
  else
    ewarn "Variable RELEASE_INFO is unset, applying fallback for usage in adjust_boot_files." ; eend 1
    release_info="$GRML_NAME $VERSION - Release Codename $RELEASENAME"
  fi

  # ensure this has a specific length
  local fixed_release_info
  fixed_release_info="$(cut_string 68 "$release_info")"
  fixed_release_info="$(extend_string_end 68 "$fixed_release_info")"

  for file in "$@" ; do
    if [ -r "${file}" ] && [ -f "${file}" ] ; then
      sed -i "s/%ARCH%/$ARCH/g"                    "${file}"
      sed -i "s/%DATE%/$DATE/g"                    "${file}"
      sed -i "s/%DISTRI_INFO%/$DISTRI_INFO/g"      "${file}"
      sed -i "s/%DISTRI_NAME%/$DISTRI_NAME/g"      "${file}"
      sed -i "s/%DISTRI_SPLASH%/$DISTRI_SPLASH/g"  "${file}"
      sed -i "s/%GRML_NAME%/$GRML_NAME/g"          "${file}"
      sed -i "s/%SQUASHFS_NAME%/$SQUASHFS_NAME/g"  "${file}"
      sed -i "s/%RELEASE_INFO%/$fixed_release_info/g" "${file}"
      sed -i "s/%SHORT_NAME%/$SHORT_NAME/g"        "${file}"
      sed -i "s/%VERSION%/$VERSION/g"              "${file}"
      if [ -n "${BOOT_FILE}" ] ; then
        sed -i "s;%BOOT_FILE%;$BOOT_FILE;g"        "${file}"
      fi

      [ -n "$DEFAULT_BOOTOPTIONS" ] && sed -i "s; boot=live; boot=live $DEFAULT_BOOTOPTIONS;"  "${file}"

      if [ -n "$NO_BOOTID" ] ; then
        sed -i "s/ bootid=%BOOTID%//g" "${file}" # drop bootid bootoption
      else
        sed -i "s/%BOOTID%/$BOOTID/g" "${file}" # adjust bootid=... argument
      fi
    fi
  done
}
# }}}

# command line parsing {{{
while getopts "a:C:c:d:D:e:g:i:I:o:r:s:S:t:U:v:w:AbBFhnNqQuVz" opt; do
  case "$opt" in
    a) ARCH="$OPTARG" ;;
    A) CLEAN_ARTIFACTS=1 ;;
    b) BUILD_ONLY=1 ;;
    B) BUILD_DIRTY=1 ;;
    c) CLASSES="$OPTARG" ;;
    C) LOCAL_CONFIG="$(readlink -f "$OPTARG")" ;;
    d) DATE="$OPTARG" ;;
    D) GRML_FAI_CONFIG="$(readlink -f "$OPTARG")" ;;
    e) EXTRACT_ISO_NAME="$(readlink -f "$OPTARG")" ;;
    g) GRML_NAME="$OPTARG" ;;
    h) usage ; bailout 0 ;;
    i) ISO_NAME="$OPTARG" ;;
    I) CHROOT_INSTALL="$OPTARG" ;;
    n) SKIP_MKISOFS=1 ;;
    N) BOOTSTRAP_ONLY=1; SKIP_MKISOFS=1; SKIP_MKSQUASHFS=1 ;;
    o) OUTPUT="$(readlink -f "$OPTARG")" ;;
    q) SKIP_MKSQUASHFS=1 ;;
    Q) SKIP_NETBOOT=1 ;;
    r) RELEASENAME="$OPTARG" ;;
    s) SUITE="$OPTARG" ;;
    S) SCRIPTS_DIRECTORY="$OPTARG";;
    t) TEMPLATE_DIRECTORY="$OPTARG";;
    v) VERSION="$OPTARG" ;;
    F) FORCE=1 ;;
    u) UPDATE=1 ;;
    U) CHOWN_USER="$OPTARG" ;;
    V) echo "grml-live option -V is deprecated, please remove it." ;;
    w) export WAYBACK_DATE="$OPTARG" ;;
    z) SQUASHFS_ZLIB=1 ;;
    ?) echo "invalid option -$OPTARG" >&2; usage; bailout 1 ;;
  esac
done
shift $((OPTIND - 1))  # set ARGV to the first not parsed commandline parameter

if [ -n "$1" ] ; then
  echo "Error: unknown argument '$1' in options. Exiting to avoid possible data loss." >&2
  bailout 1
fi
# }}}

# read local (non-packaged) configuration {{{
if [ -z "$LOCAL_CONFIG" ]; then
  if [ -r "/etc/grml/grml-live.local" ]; then
    LOCAL_CONFIG="/etc/grml/grml-live.local"
  fi
fi
if [ -n "$LOCAL_CONFIG" ]; then
  if [ -r "$LOCAL_CONFIG" ]; then
    # shellcheck source=/dev/null
    . "$LOCAL_CONFIG"
  else
    eerror "Could not read specified local configuration file \"$LOCAL_CONFIG\"."
    bailout 1
  fi
  LOCAL_CONFIG=$(readlink -f "$LOCAL_CONFIG")
else
  LOCAL_CONFIG=''
fi
# }}}

# assume sane defaults (if not set already) {{{
[ -n "$ARCH" ]                    || ARCH="$(dpkg --print-architecture)"
[ -n "$CLASSES" ]                 || CLASSES="GRMLBASE,GRML_FULL,$(echo "${ARCH}" | tr '[:lower:]' '[:upper:]')"
[ -n "$DATE" ]                    || DATE="$(date +%Y-%m-%d)"
[ -n "$DISTRI_INFO" ]             || DISTRI_INFO='Grml - Live Linux for system administrators'
[ -n "$DISTRI_NAME" ]             || DISTRI_NAME="grml"
[ -n "$DISTRI_SPLASH" ]           || DISTRI_SPLASH='grml.png'
[ -n "$FORCE_ISO_REBUILD" ]       || FORCE_ISO_REBUILD="false"
[ -n "$GRML_FAI_CONFIG" ]         || GRML_FAI_CONFIG='/usr/share/grml-live/config'
[ -n "$GRML_NAME" ]               || GRML_NAME='grml'
[ -n "$HOSTNAME" ]                || HOSTNAME='grml'
[ -n "$HYBRID_METHOD" ]           || HYBRID_METHOD='isohybrid'
[ -n "$RELEASENAME" ]             || RELEASENAME='grml-live rocks'
[ -n "$SECURE_BOOT" ]             || SECURE_BOOT='disable'
[ -n "$SQUASHFS_BINARY" ]         || SQUASHFS_BINARY='mksquashfs'
[ -n "$SQUASHFS_EXCLUDES_FILE" ]  || SQUASHFS_EXCLUDES_FILE="${GRML_FAI_CONFIG}/grml/squashfs-excludes"
[ -n "$SUITE" ]                   || SUITE='testing'
[ -n "$TEMPLATE_DIRECTORY" ]      || TEMPLATE_DIRECTORY='/usr/share/grml-live/templates'
[ -n "$SCRIPTS_DIRECTORY" ]       || SCRIPTS_DIRECTORY='/usr/share/grml-live/scripts'
[ -n "$USERNAME" ]                || USERNAME='grml'
[ -n "$VERSION" ]                 || VERSION='0.0.1'

# output specific stuff, depends on $OUTPUT (iff not set):
[ -n "$OUTPUT" ]           || OUTPUT="$PWD/grml/"
[ -n "$BUILD_OUTPUT" ]     || BUILD_OUTPUT="$OUTPUT/grml_cd"
[ -n "$CHROOT_OUTPUT" ]    || CHROOT_OUTPUT="$OUTPUT/grml_chroot"
[ -n "$ISO_OUTPUT" ]       || ISO_OUTPUT="$OUTPUT/grml_isos"
[ -n "$LOG_OUTPUT" ]       || LOG_OUTPUT="$OUTPUT/grml_logs"
[ -n "$REPORTS" ]          || REPORTS="${LOG_OUTPUT}/reports"
[ -n "$NETBOOT" ]          || NETBOOT="${OUTPUT}/netboot"
# }}}

# some misc checks before doing work {{{
[ -n "$CLASSES" ] || bailout 1 "Error: \$CLASSES unset, please set it in $LIVE_CONF or
specify it on the command line using the -c option."
[ -n "$OUTPUT" ] || bailout 1 "Error: \$OUTPUT unset, please set it in $LIVE_CONF or
specify it on the command line using the -o option."

if [ "$ARCH" != "i386" ] && [ "$ARCH" != "amd64" ] && [ "$ARCH" != "arm64" ] ; then
  eerror 'Error: Unsupported ARCH, sorry. Want to support it? Contribute!'
  eend 1
  bailout
fi

if [[ "$(dpkg --print-architecture)" != "arm64" ]] && [[ "$ARCH" == "arm64" ]] ; then
  eerror "Failure: trying to build for arm64, but not running on arm64."
  eend 1
  bailout
fi

if [ -e "$GRML_FAI_CONFIG"/fai.conf ] ; then
  ewarn "The file ${GRML_FAI_CONFIG}/fai.conf exists but will be ignored."
  eend 1
fi

if [ -n "$FAI_ARGS" ] ; then
  eerror "The variable \$FAI_ARGS is set, but it is unsupported." ; eend 1
  eerror "Please unset it. Current value: \$FAI_ARGS=$FAI_ARGS" ; eend 1
  bailout
fi

if [ -n "$FAI_DEBOOTSTRAP_OPTS" ] ; then
  eerror "The variable \$FAI_DEBOOTSTRAP_OPTS is set, but it is unsupported." ; eend 1
  eerror "Current value: \$FAI_DEBOOTSTRAP_OPTS=${FAI_DEBOOTSTRAP_OPTS}" ; eend 1
  bailout
fi

if [ -e /etc/grml/fai/config ] && [ -z "$GRML_FAI_CONFIG" ] ; then
  eerror "Found old configuration files in /etc/grml/fai/config (while \$GRML_FAI_CONFIG was empty)." ; eend 1
  eerror "You should check your configuration and move these files into a new path, and set \$GRML_FAI_CONFIG." ; eend 1
  bailout
fi

if [ -e "$GRML_FAI_CONFIG"/config ] ; then
  eerror "The path ${GRML_FAI_CONFIG}/config exists, very likely your \$GRML_FAI_CONFIG is invalid." ; eend 1
  eerror "Either set \$GRML_FAI_CONFIG=${GRML_FAI_CONFIG}/config or delete ${GRML_FAI_CONFIG}/config." ; eend 1
  bailout
fi

# trim characters that are known to cause problems inside $GRML_NAME;
# for example isolinux does not like '-' inside the directory name
[ -n "$GRML_NAME" ] && SHORT_NAME="$(echo "$GRML_NAME" | tr -d ',./;\- ')"
# }}}

# Warn user if addons from grml-live-addons are absent {{{
if [ -z "${NO_ADDONS:-}" ] && [ ! -r "$TEMPLATE_DIRECTORY"/arch ] ; then
  ewarn "Boot addons not found (Consider installing package grml-live-addons)" ; eend 0
fi
# }}}

# Show configuration and ask user whether to continue {{{
echo
echo "${PN} [${GRML_LIVE_VERSION}] Build Configuration:"
echo
echo "  FAI classes:       $CLASSES"
[ -n "$LOCAL_CONFIG" ]        && echo "  Configuration:     $LOCAL_CONFIG"
[ -n "$GRML_FAI_CONFIG" ]     && echo "  Config directory:  $GRML_FAI_CONFIG"
echo "  main directory:    $OUTPUT"
[ -n "$EXTRACT_ISO_NAME" ]    && echo "  Extract ISO:       $EXTRACT_ISO_NAME"
[ -n "$CHROOT_OUTPUT" ]       && echo "  Chroot target:     $CHROOT_OUTPUT"
[ -n "$BUILD_OUTPUT" ]        && echo "  Build target:      $BUILD_OUTPUT"
[ -n "$ISO_OUTPUT" ]          && echo "  ISO target:        $ISO_OUTPUT"
[ -n "$GRML_NAME" ]           && echo "  Grml name:         $GRML_NAME"
[ -n "$RELEASENAME" ]         && echo "  Release name:      $RELEASENAME"
[ -n "$DATE" ]                && echo "  Build date:        $DATE"
[ -n "$WAYBACK_DATE" ]        && echo "  Wayback date:      $WAYBACK_DATE"
[ -n "$VERSION" ]             && echo "  Grml version:      $VERSION"
[ -n "$SUITE" ]               && echo "  Debian suite:      $SUITE"
[ -n "$ARCH" ]                && echo "  Architecture:      $ARCH"
[ -n "$HYBRID_METHOD" ]       && echo "  Hybrid method:     $HYBRID_METHOD"
[ -n "$SECURE_BOOT" ]         && echo "  Secure Boot:       $SECURE_BOOT"
[ -n "$TEMPLATE_DIRECTORY" ]  && echo "  Template files:    $TEMPLATE_DIRECTORY"
[ -n "$CHROOT_INSTALL" ]      && echo "  Install files from directory to chroot:  $CHROOT_INSTALL"
[ -n "$BOOTID" ]              && echo "  Boot identifier:   $BOOTID"
[ -n "$NO_BOOTID" ]           && echo "  Skipping bootid feature."
[ -n "$CHOWN_USER" ]          && echo "  Output owner:      $CHOWN_USER"
[ -n "$DEFAULT_BOOTOPTIONS" ] && echo "  Adding default bootoptions: \"$DEFAULT_BOOTOPTIONS\""
[ -n "$LOGFILE" ]             && echo "  Logging to file:   $LOGFILE"
[ -n "$SQUASHFS_ZLIB" ]       && echo "  Using ZLIB (instead of LZMA/XZ) compression."
[ -n "$SQUASHFS_OPTIONS" ]    && echo "  Using SQUASHFS_OPTIONS ${SQUASHFS_OPTIONS}"
[ -n "$CLEAN_ARTIFACTS" ]     && echo "  Will clean output before and after running."
[ -n "$UPDATE" ]              && echo "  Executing UPDATE instead of fresh installation."
if [ -n "$BOOTSTRAP_ONLY" ] ; then
    echo "  Bootstrapping only and not building (files for) ISO."
else
    [ -n "$SKIP_MKSQUASHFS" ]     && echo "  Skipping creation of SQUASHFS file."
    [ -n "$SKIP_NETBOOT" ]        && echo "  Skipping creation of NETBOOT package."
    [ -n "$SKIP_MKISOFS" ]        && echo "  Skipping creation of ISO file."
    [ -n "$NO_ADDONS" ]           && echo "  Skipping boot addons."
    [ -n "$BUILD_ONLY" ]          && echo "  Executing BUILD_ONLY instead of fresh installation or UPDATE."
    [ -n "$BUILD_DIRTY" ]         && echo "  Executing BUILD_DIRTY to leave chroot untouched."
fi
echo
if [ -z "$FORCE" ] ; then
   echo "Check the configuration above, or use -F to force execution."
   echo
   echo -n "Continue? [y/N] "
   read -r a
   if ! [ "$a" = 'y' ] || [ "$a" = 'Y' ] ; then
      CLEAN_ARTIFACTS=0
      echo "Exiting as requested."
      exit 0
   fi
   echo
fi
# }}}

# clean up before start {{{
if [ -n "${CLEAN_ARTIFACTS}" ]; then
  echo "Wiping old artifacts"
  [ -n "${CHROOT_OUTPUT}"  ] && [ -d "${CHROOT_OUTPUT}"  ] && rm -r "${CHROOT_OUTPUT}"
  [ -n "${BUILD_OUTPUT}"   ] && [ -d "${BUILD_OUTPUT}"   ] && rm -r "${BUILD_OUTPUT}"
  [ -n "${ISO_OUTPUT}"     ] && [ -d "${ISO_OUTPUT}"     ] && rm -r "${ISO_OUTPUT}"
  [ -n "${LOG_OUTPUT}"     ] && [ -d "${LOG_OUTPUT}"     ] && rm -r "${LOG_OUTPUT}"
  [ -n "${NETBOOT}"        ] && [ -d "${NETBOOT}"        ] && rm -r "${NETBOOT}"
fi
# }}}

# create log file {{{
[ -n "$LOGFILE" ] || LOGFILE=${LOG_OUTPUT}/grml-live.log
mkdir -p "$(dirname "${LOGFILE}")"
touch "$LOGFILE"
chown root:adm "$LOGFILE"
chmod 664 "$LOGFILE"
if [ -n "$PRESERVE_LOGFILE" ] ; then
   echo "Preserving logfile $LOGFILE as requested via \$PRESERVE_LOGFILE"
else
   # make sure it is empty
   echo -n > "$LOGFILE"
fi
# }}}

# source config and startup {{{
if [ -n "$CONFIG" ] ; then
   if ! [ -f "$CONFIG" ] ; then
      log    "Error: $CONFIG could not be read. Exiting. [$(date)]"
      eerror "Error: $CONFIG could not be read. Exiting." ; eend 1
      bailout 1
   else
      log "Sourcing $CONFIG"
      # shellcheck source=/dev/null
      . "$CONFIG"
   fi
fi

SECONDS=unknown
start_seconds="$(date +%s)"
log "------------------------------------------------------------------------------"
log "Starting grml-live [${GRML_LIVE_VERSION}] run on $(date)"
log "Using local config file: $LOCAL_CONFIG"
log "Executed grml-live command line:"
log "$CMDLINE"

einfo "Logging actions to logfile $LOGFILE"
# }}}

# dump config variables into file, for hooks/scripts access {{{
CONFIGDUMP=$(mktemp)
set | grep -E \
  '^(GRML_NAME|RELEASENAME|DATE|VERSION|SUITE|ARCH|DISTRI_NAME|TEMPLATE_DIRECTORY|USERNAME|HOSTNAME|APT_PROXY|BUILD_ONLY|BOOTSTRAP_ONLY|WAYBACK_DATE)=' \
  > "${CONFIGDUMP}"
# }}}

# unpack iso/squashfs {{{
extract_iso() {
if [ -n "$EXTRACT_ISO_NAME" ]; then
  log "Unpacking ISO from ${EXTRACT_ISO_NAME}"
  einfo "Unpacking ISO from ${EXTRACT_ISO_NAME}"
  local rc=0
  local tempdir
  tempdir=$(mktemp -d)
  mkdir -p "${tempdir}/live/"
  osirrox -indev "${EXTRACT_ISO_NAME}" -extract live "${tempdir}/live/" ; rc=$?
  if [ "$rc" != 0 ]; then
    rm -rf "$tempdir"
    log "osirrox failed"
    eerror "osirrox failed"
    eend 1
    bailout 1
  fi

  local squashfs
  squashfs=( "${tempdir}"/live/*/*.squashfs )
  if (( ${#squashfs[@]} != 0 )) && [ -r "${squashfs[0]}" ]; then
    log "Will unsquashfs ${squashfs[0]}"
    unsquashfs -d "${CHROOT_OUTPUT}" "${squashfs[0]}" ; rc=$?
  else
    log "Error: Could not find any *.squashfs files on the ISO"
    eerror "Error: Could not find any *.squashfs files on the ISO"
    eend 1
    bailout 1
  fi

  rm -rf "$tempdir"
  if [ "$rc" != 0 ]; then
    log "unsquashfs failed"
    eerror "unsquashfs failed"
    eend 1
    bailout 1
  fi
fi
}
extract_iso
# }}}

# on-the-fly configuration {{{

case "${SUITE}" in
  # /usr/share/debootstrap/scripts/unstable does not exist, so use 'sid'
  # for bootstrapping, but DEBIAN_UNSTABLE elsewhere:
   unstable) SUITE='sid' ; CLASSES="DEBIAN_UNSTABLE,$CLASSES" ;;
  # avoid having to maintain DEBIAN_UNSTABLE *and* DEBIAN_SID class files:
        sid)               CLASSES="DEBIAN_UNSTABLE,$CLASSES" ;;
  # otherwise map e.g. bookworm to DEBIAN_BOOKWORM:
          *)               CLASSES="DEBIAN_$(echo "$SUITE" | tr '[:lower:]' '[:upper:]'),$CLASSES";;
esac
export SUITE # make sure it's available in FAI scripts

# validate whether the specified architecture class matches the
# architecture (option), otherwise installation of kernel will fail
if hasclass I386 ; then
   if ! [[ "$ARCH" == "i386" ]] ; then
      log    "Error: You specified the I386 class but are trying to build something else (AMD64/ARM64?)."
      eerror "Error: You specified the I386 class but are trying to build something else (AMD64/ARM64?)."
      eerror "Tip:   Either invoke grml-live with '-a i386' or adjust the architecture class. Exiting."
      eend 1
      bailout
   fi
elif hasclass AMD64 ; then
   if ! [[ "$ARCH" == "amd64" ]] ; then
      log    "Error: You specified the AMD64 class but are trying to build something else (I386/ARM64?)."
      eerror "Error: You specified the AMD64 class but are trying to build something else (I386/ARM64?)."
      eerror "Tip:   Either invoke grml-live with '-a amd64' or adjust the architecture class. Exiting."
      eend 1
      bailout
   fi
elif hasclass ARM64 ; then
   if ! [[ "$ARCH" == "arm64" ]] ; then
      log    "Error: You specified the ARM64 class but are trying to build something else (I386/AMD64?)."
      eerror "Error: You specified the ARM64 class but are trying to build something else (I386/AMD64?)."
      eerror "Tip:   Either invoke grml-live with '-a arm64' or adjust the architecture class. Exiting."
      eend 1
      bailout
   fi
fi

if [[ -n "${BOOT_METHOD:-}" ]] && [[ "${BOOT_METHOD}" != "isolinux" ]] ; then
  log    "Error: You specified unsupported BOOT_METHOD '${BOOT_METHOD:-}', though only isolinux is supported."
  eerror "Error: You specified unsupported BOOT_METHOD '${BOOT_METHOD:-}', though only isolinux is supported."
  eerror "NOTE:  The BOOT_METHOD configuration is deprecated, please consider unsetting it. Exiting."
  eend 1
  bailout
fi

# continue to support $FAI_DEBOOTSTRAP to specify the Debian suite and mirror URL.
if [ -z "$FAI_DEBOOTSTRAP" ] ; then
  if [ -n "$WAYBACK_DATE" ] ; then
    FAI_DEBOOTSTRAP="$SUITE http://snapshot.debian.org/archive/debian/$WAYBACK_DATE/"
  else
    FAI_DEBOOTSTRAP="$SUITE http://deb.debian.org/debian"
  fi
fi
# }}}

# CHROOT_OUTPUT - execute FAI {{{
if [ -n "$BUILD_DIRTY" ]; then
   log   "Skipping stage 'fai' as requested via option -B"
   ewarn "Skipping stage 'fai' as requested via option -B" ; eend 0
else
   [ -n "$CHROOT_OUTPUT" ] || CHROOT_OUTPUT="$OUTPUT/grml_chroot"

   if [ -n "$UPDATE" ] || [ -n "$BUILD_ONLY" ] ; then
      FAI_ACTION=softupdate
   else
      FAI_ACTION=dirinstall
   fi

   if [ -n "$UPDATE" ] || [ -n "$BUILD_ONLY" ] ; then
      if ! [ -r "$CHROOT_OUTPUT/etc/debian_version" ] ; then
         log    "Error: does not look like you have a working chroot. Updating/building not possible."
         eerror "Error: does not look like you have a working chroot. Updating/building not possible. (Drop -u/-b option?)"
         eend 1
         bailout 20
      fi
   fi

   if [ -d "$CHROOT_OUTPUT/bin" ] && [ -z "$UPDATE" ] && [ -z "$BUILD_ONLY" ] ; then
      log   "Skipping stage 'fai $FAI_ACTION' as $CHROOT_OUTPUT exists already."
      ewarn "Skipping stage 'fai $FAI_ACTION' as $CHROOT_OUTPUT exists already." ; eend 0
   else
      mkdir -p "$CHROOT_OUTPUT" || bailout 5 "Problem with creating $CHROOT_OUTPUT for FAI"

      if [ -n "${MIRROR_DIRECTORY}" ] ; then
         mkdir -p "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
         mount --bind "${MIRROR_DIRECTORY}" "${CHROOT_OUTPUT}/${MIRROR_DIRECTORY}"
      fi

      mkdir -p "${OUTPUT}"/grml_sources "${CHROOT_OUTPUT}"/grml-live/
      mv "${OUTPUT}"/grml_sources "${CHROOT_OUTPUT}"/grml-live/

      log "Executed FAI command line:"
      log "${FAI_PROGRAM} ${GRML_FAI_CONFIG} ${CLASSES} ${FAI_ACTION} ${CHROOT_OUTPUT} ${CONFIGDUMP} ${FAI_DEBOOTSTRAP}"
      einfo "${FAI_PROGRAM} ${GRML_FAI_CONFIG} ${CLASSES} ${FAI_ACTION} ${CHROOT_OUTPUT} ${CONFIGDUMP} ${FAI_DEBOOTSTRAP}"
      # shellcheck disable=SC2086 # $FAI_DEBOOTSTRAP needs splitting
      "${FAI_PROGRAM}" "${GRML_FAI_CONFIG}" "${CLASSES}" "${FAI_ACTION}" "${CHROOT_OUTPUT}" "${CONFIGDUMP}" ${FAI_DEBOOTSTRAP} 2>&1 | tee -a "${LOGFILE}"
      RC="${PIPESTATUS[0]}" # notice: bash-only

      # Fetches logs from "${CHROOT_OUTPUT}"/grml-live/log.
      # Also run this on failure.
      store_logfiles

      if [ "$RC" != 0 ] ; then
        log    "Error: critical error while executing fai [exit code ${RC}]. Exiting."
        eerror "Error: critical error while executing fai [exit code ${RC}]. Exiting." ; eend 1
        bailout 1
      fi

      mv "${CHROOT_OUTPUT}"/grml-live/grml_sources/ "${OUTPUT}"
      rmdir "${CHROOT_OUTPUT}"/grml-live

      # provide inform fai about the ISO we build, needs to be provided
      # *after* FAI stage, otherwise FAI skips the debootstrap stage if
      # there is not BASEFILE (as it checks for presence of /etc) :(
      echo '# This file has been generated by grml-live.' > "$CHROOT_OUTPUT/etc/grml_live_version"
      [ -n "$GRML_LIVE_VERSION" ] && echo "GRML_LIVE_VERSION=$GRML_LIVE_VERSION" >> "$CHROOT_OUTPUT/etc/grml_live_version"
      [ -n "$SUITE" ] && echo "SUITE=$SUITE" >> "$CHROOT_OUTPUT/etc/grml_live_version"

      FORCE_ISO_REBUILD=true

      umount_all

      log "Finished execution of stage 'fai $FAI_ACTION' [$(date)]"
      einfo "Finished execution of stage 'fai $FAI_ACTION'"
   fi
fi # BUILD_DIRTY?
# }}}

# grub boot {{{
grub_setup() {
  EFI_IMG="/boot/efi.img"

  local efi_size
  if [[ "${SECURE_BOOT:-}" == "disable" ]] || [[ "${ARCH:-}" == "i386" ]] ; then
    efi_size='4M'
  else
    # e.g. templates/EFI/debian for Secure Boot has >4MB and needs more space
    efi_size='8M'
  fi

  if [[ "$ARCH" == "amd64" ]] || [[ "$ARCH" == "arm64" ]] ; then
    case "$ARCH" in
      arm64)
        BOOTX64="/boot/bootaa64.efi"
        ;;
      amd64)
        BOOTX64="/boot/bootx64.efi"
        BOOTX32="/boot/bootia32.efi"
        ;;
    esac

    # important: this depends on execution of ${GRML_FAI_CONFIG}/scripts/GRMLBASE/45-grub-images
    if ! [ -r "${CHROOT_OUTPUT}/${BOOTX64}" ] ; then
      log    "Cannot access GRUB UEFI image ${CHROOT_OUTPUT}/${BOOTX64}, required for Secure Boot support"
      eerror "Cannot access GRUB UEFI image ${CHROOT_OUTPUT}/${BOOTX64}, required for Secure Boot support" ; eend 1
      log    "Possible reason is failure to run ${GRML_FAI_CONFIG}/scripts/GRMLBASE/45-grub-images"
      ewarn  "Possible reason is failure to run ${GRML_FAI_CONFIG}/scripts/GRMLBASE/45-grub-images"
      bailout 50
    fi

    # UEFI 32bit boot support, only supported with Debian trixie and newer,
    # so make it optional and don't fail hard
    if [[ "$ARCH" == "amd64" ]] && ! [ -r "${CHROOT_OUTPUT}/${BOOTX32}" ] ; then
      local uefi_32bit_support
      uefi_32bit_support=0
      log   "Cannot access GRUB 32-bit PC EFI image ${CHROOT_OUTPUT}/${BOOTX32}, disabling UEFI 32bit boot support."
      ewarn "Cannot access GRUB 32-bit PC EFI image ${CHROOT_OUTPUT}/${BOOTX32}, disabling UEFI 32bit boot support" ; eend 0
    fi

    dd if=/dev/zero of="${CHROOT_OUTPUT}/${EFI_IMG}" bs="${efi_size}" count=1 2>/dev/null || bailout 50
    mkfs.vfat -n GRML "${CHROOT_OUTPUT}/${EFI_IMG}" >/dev/null || bailout 51
    mmd -i "${CHROOT_OUTPUT}/${EFI_IMG}" ::EFI || bailout 52
    mmd -i "${CHROOT_OUTPUT}/${EFI_IMG}" ::EFI/BOOT || bailout 52

    if [ "${SECURE_BOOT:-}" = "disable" ] ; then
      log   "Secure Boot is disabled."
      einfo "Secure Boot is disabled." ; eend 0

      # install "$BOOTX64" as ::EFI/BOOT/{bootx64.efi|bootaa64.efi} inside image file "$EFI_IMG",
      # and if present also "$BOOTX32" as ::EFI/BOOT/bootia32.efi on amd64 for UEFI 32bit boot support:
      case "$ARCH" in
        arm64)
          mcopy -i "${CHROOT_OUTPUT}/${EFI_IMG}" "${CHROOT_OUTPUT}/${BOOTX64}" ::EFI/BOOT/bootaa64.efi >/dev/null || bailout 53
          ;;
        amd64)
          mcopy -i "${CHROOT_OUTPUT}/${EFI_IMG}" "${CHROOT_OUTPUT}/${BOOTX64}" ::EFI/BOOT/bootx64.efi >/dev/null || bailout 53
          # UEFI 32bit boot
          if [ "${uefi_32bit_support:-}" != "0" ] ; then
            mcopy -i "${CHROOT_OUTPUT}/${EFI_IMG}" "${CHROOT_OUTPUT}/${BOOTX32}" ::EFI/BOOT/bootia32.efi >/dev/null || bailout 53
          fi
          ;;
      esac

      log   "Created UEFI image $EFI_IMG from $BOOTX64 ${BOOTX32:-}"
      einfo "Created UEFI image $EFI_IMG from $BOOTX64 ${BOOTX32:-}" ; eend 0
    else
      case "${SECURE_BOOT}" in
        disable*)
          log   "Secure Boot is disabled [mode: ${SECURE_BOOT}]"
          einfo "Secure Boot is disabled [mode: ${SECURE_BOOT}]" ; eend 0
          ;;
        debian|ubuntu)
          log   "Secure Boot is enabled [mode: ${SECURE_BOOT}]"
          einfo "Secure Boot is enabled [mode: ${SECURE_BOOT}]" ; eend 0

          local GRUBCFG_TEMPLATE="${TEMPLATE_DIRECTORY}/secureboot/grub.cfg"
          local GRUBCFG_TMP
          GRUBCFG_TMP=$(mktemp)

          if ! [ -r "${GRUBCFG_TEMPLATE}" ] ; then
            log    "Secure Boot template for GRUB [${GRUBCFG_TEMPLATE}] not found."
            eerror "Secure Boot template for GRUB [${GRUBCFG_TEMPLATE}] not found." ; eend 1
            bailout 54
          fi

          cp "${GRUBCFG_TEMPLATE}" "${GRUBCFG_TMP}"
          adjust_boot_files "${GRUBCFG_TMP}"

          mmd -i "${CHROOT_OUTPUT}/${EFI_IMG}" ::boot      || bailout 55
          mmd -i "${CHROOT_OUTPUT}/${EFI_IMG}" ::boot/grub || bailout 55
          mcopy -i "${CHROOT_OUTPUT}/${EFI_IMG}" "${GRUBCFG_TMP}" ::boot/grub/grub.cfg || bailout 56

          rm "${GRUBCFG_TMP}"

          if [ -r "${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/grubx64.efi.signed" ] ; then
            mcopy -i "${CHROOT_OUTPUT}/${EFI_IMG}" "${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/grubx64.efi.signed" ::EFI/BOOT/grubx64.efi >/dev/null || bailout 57
          else
            log    "Secure Boot GRUB binary '${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/grubx64.efi.signed' not found."
            eerror "Secure Boot GRUB binary '${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/grubx64.efi.signed' not found." ; eend 1
            bailout 57
          fi

          if [ -r "${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/shimx64.efi.signed" ] ; then
            mcopy -i "${CHROOT_OUTPUT}/${EFI_IMG}" "${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/shimx64.efi.signed" ::EFI/BOOT/bootx64.efi >/dev/null || bailout 58
          else
            log    "Secure Boot GRUB binary '${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/shimx64.efi.signed' not found."
            eerror "Secure Boot GRUB binary '${TEMPLATE_DIRECTORY}/EFI/${SECURE_BOOT}/BOOT/shimx64.efi.signed' not found." ; eend 1
            bailout 57
          fi

          log   "Created Secure Boot (${SECURE_BOOT}) UEFI image ${CHROOT_OUTPUT}/${EFI_IMG}"
          einfo "Created Secure Boot (${SECURE_BOOT}) UEFI image ${CHROOT_OUTPUT}/${EFI_IMG}" ; eend 0
          ;;
        *)
          log   "Secure Boot method '${SECURE_BOOT}' is unsupported."
          eerror "Secure Boot method '${SECURE_BOOT}' is unsupported." ; eend 1
          bailout 59
          ;;
      esac
    fi
  fi

  if [[ "$ARCH" == "i386" ]] ; then
    BOOTX32="/boot/bootia32.efi"
    if ! [ -r "${CHROOT_OUTPUT}/${BOOTX32}" ] ; then
      log    "Cannot access GRUB 32-bit PC EFI image ${CHROOT_OUTPUT}/${BOOTX32}."
      eerror "Cannot access GRUB 32-bit PC EFI image ${CHROOT_OUTPUT}/${BOOTX32}." ; eend 1
      log    "Possible reason is failure to run ${GRML_FAI_CONFIG}/scripts/GRMLBASE/45-grub-images"
      ewarn  "Possible reason is failure to run ${GRML_FAI_CONFIG}/scripts/GRMLBASE/45-grub-images"
      bailout 50
    fi

    dd if=/dev/zero of="${CHROOT_OUTPUT}/${EFI_IMG}" bs="${efi_size}" count=1 2>/dev/null || bailout 50
    mkfs.vfat -n GRML "${CHROOT_OUTPUT}/${EFI_IMG}" >/dev/null || bailout 51
    mmd -i "${CHROOT_OUTPUT}/${EFI_IMG}" ::EFI || bailout 52
    mmd -i "${CHROOT_OUTPUT}/${EFI_IMG}" ::EFI/BOOT || bailout 52
    mcopy -i "${CHROOT_OUTPUT}/${EFI_IMG}" "${CHROOT_OUTPUT}/${BOOTX32}" ::EFI/BOOT/bootia32.efi >/dev/null || bailout 53
    log   "Created 32-bit PC EFI image $EFI_IMG from $BOOTX32"
    einfo "Created 32-bit PC EFI image $EFI_IMG from $BOOTX32" ; eend 0
  fi
}
# }}}

# BUILD_OUTPUT - execute arch specific stuff and squashfs {{{
[ -n "$BUILD_OUTPUT" ] || BUILD_OUTPUT="$OUTPUT/grml_cd"
mkdir -p "$BUILD_OUTPUT" || bailout 6 "Problem with creating $BUILD_OUTPUT for stage ARCH"

# prepare ISO
if [ -n "$BOOTSTRAP_ONLY" ] ; then
  log   "Skipping stage 'boot' as building with bootstrap only."
  ewarn "Skipping stage 'boot' as building with bootstrap only." ; eend 0
else
  # Install boot code
  mkdir -p "$BUILD_OUTPUT"/boot/"${SHORT_NAME}"

  # this is a variable we're using for adjusting boot templates, not only in
  # adjust_boot_files though, so set here
  RELEASE_INFO="$GRML_NAME $VERSION - Release Codename $RELEASENAME"

  # if we don't have an initrd we a) can't boot and b) there was an error
  # during build, so check for the file:
  # shellcheck disable=SC2010 disable=SC2012 # We do not expect fancy characters here.
  INITRD=$(ls "$CHROOT_OUTPUT"/boot/initrd* 2>/dev/null| grep -v '.bak$' | sort -r | head -1)
  if [ -n "$INITRD" ] ; then
    cp "$INITRD" "$BUILD_OUTPUT"/boot/"${SHORT_NAME}"/initrd.img
    find "$CHROOT_OUTPUT"/boot/ -name initrd\*.bak -exec rm {} \;
  else
    log    "Error: No initrd found inside $CHROOT_OUTPUT/boot/ - Exiting"
    eerror "Error: No initrd found inside $CHROOT_OUTPUT/boot/ - Exiting" ; eend 1
    bailout 10
  fi

  # shellcheck disable=SC2010 disable=SC2012 # We do not expect fancy characters here.
  KERNEL_IMAGE=$(ls "$CHROOT_OUTPUT"/boot/vmlinuz* 2>/dev/null | sort -r | head -1)
  if [ -n "$KERNEL_IMAGE" ] ; then
    cp "$KERNEL_IMAGE" "$BUILD_OUTPUT"/boot/"${SHORT_NAME}"/vmlinuz
  else
    log    "Error: No kernel found inside $CHROOT_OUTPUT/boot/ - Exiting"
    eerror "Error: No kernel found inside $CHROOT_OUTPUT/boot/ - Exiting" ; eend 1
    bailout 11
  fi

  # we need to set "$BOOTID" before we invoke adjust_boot_files for the
  # first time, being inside grub_setup below
  if [ -n "$NO_BOOTID" ] ; then
    log   "Skipping bootid feature as requested via \$NO_BOOTID."
    einfo "Skipping bootid feature as requested via \$NO_BOOTID."
  else
    [ -n "$BOOTID" ] || BOOTID=$(echo "${GRML_NAME}${VERSION}" | tr -d ',./;\- ')
    mkdir -p "$BUILD_OUTPUT"/conf
    einfo "Generating /conf/bootid.txt with entry ${BOOTID}."
    log   "Generating /conf/bootid.txt with entry ${BOOTID}."
    echo "$BOOTID" > "$BUILD_OUTPUT"/conf/bootid.txt
    eend 0
  fi

  # every recent Grml ISO ships a /conf/bootid.txt, though GRUB might find
  # the /conf/bootid.txt of a different (Grml) ISO than the one that's
  # supposed to be running, so within scripts/GRMLBASE/45-grub-images
  # we generate a random filename, stored inside /boot/grub/bootfile.txt,
  # which we place on the resulting ISO here
  if [ -r "${CHROOT_OUTPUT}"/boot/grub/bootfile.txt ] ; then
    mkdir -p "${BUILD_OUTPUT}"/conf
    rm -f "${BUILD_OUTPUT}"/conf/bootfile*  # ensure we don't leave any old(er) files behind

    einfo "Generating ${BUILD_OUTPUT}/conf/bootfile* files"
    log   "Generating ${BUILD_OUTPUT}/conf/bootfile* files"

    BOOT_FILE="/conf/bootfile_$(cat "${CHROOT_OUTPUT}"/boot/grub/bootfile.txt)"
    echo "# This file is relevant for GRUB boot with the Grml ISO." > "${BUILD_OUTPUT}/${BOOT_FILE}"
    # save information about the random filename inside /conf/bootfile.txt
    echo "${BOOT_FILE}" > "${BUILD_OUTPUT}"/conf/bootfile.txt
    eend 0
  fi

  grub_setup

  # EFI boot files
  if [ -r "${CHROOT_OUTPUT}/boot/efi.img" ] && [ -r "${CHROOT_OUTPUT}/boot/bootaa64.efi" ] ; then
    einfo "Copying 64-bit EFI boot files (arm64) into ISO path."
    log   "Copying 64-bit EFI boot files (arm64) into ISO path."
    RC=0
    cp "${CHROOT_OUTPUT}/boot/efi.img" "${BUILD_OUTPUT}/boot/" || RC=$?
    mkdir -p "${BUILD_OUTPUT}/EFI/BOOT/" || RC=$?
    cp "${CHROOT_OUTPUT}/boot/bootaa64.efi" "${BUILD_OUTPUT}/EFI/BOOT/bootaa64.efi" || RC=$?
    eend "$RC"
  elif [ -r "${CHROOT_OUTPUT}/boot/efi.img" ] && [ -r "${CHROOT_OUTPUT}/boot/bootx64.efi" ] ; then
    einfo "Copying 64-bit EFI boot files (amd64) into ISO path."
    log   "Copying 64-bit EFI boot files (amd64) into ISO path."
    RC=0
    cp "${CHROOT_OUTPUT}/boot/efi.img" "${BUILD_OUTPUT}/boot/" || RC=$?
    mkdir -p "${BUILD_OUTPUT}/EFI/BOOT/" || RC=$?
    cp "${CHROOT_OUTPUT}/boot/bootx64.efi" "${BUILD_OUTPUT}/EFI/BOOT/bootx64.efi" || RC=$?
    eend "$RC"
  elif [ -r "${CHROOT_OUTPUT}/boot/efi.img" ] && [ -r "${CHROOT_OUTPUT}/boot/bootia32.efi" ] ; then
    einfo "Copying 32-bit EFI boot files into ISO path."
    log   "Copying 32-bit EFI boot files into ISO path."
    RC=0
    cp "${CHROOT_OUTPUT}/boot/efi.img" "${BUILD_OUTPUT}/boot/" || RC=$?
    mkdir -p "${BUILD_OUTPUT}/EFI/BOOT/" || RC=$?
    cp "${CHROOT_OUTPUT}/boot/bootia32.efi" "${BUILD_OUTPUT}/EFI/BOOT/bootia32.efi" || RC=$?
    eend "$RC"
  else
    ewarn "No EFI boot files found, skipping." ; eend 0
  fi

  if ! [ -d "${TEMPLATE_DIRECTORY}"/boot ] ; then
    log    "Error: ${TEMPLATE_DIRECTORY}/boot does not exist. Exiting."
    eerror "Error: ${TEMPLATE_DIRECTORY}/boot does not exist. Exiting." ; eend 1
    bailout 8
  fi

  mkdir -p "${BUILD_OUTPUT}"/boot/addons

  if [ "$ARCH" != "arm64" ] ; then
    # copy _required_ isolinux files
    mkdir -p "${BUILD_OUTPUT}"/boot/isolinux
    copy_file_logged "${BUILD_OUTPUT}"/boot/isolinux/isolinux.bin "${CHROOT_OUTPUT}" /usr/lib/ISOLINUX/isolinux.bin
    for file in "${CHROOT_OUTPUT}"/usr/lib/syslinux/modules/bios/*.c32 ; do
      file_basename=$(basename "$file")
      # Skip "big" files we do not use.
      if [ "$file_basename" != "zzjson.c32" ] && \
         [ "$file_basename" != "lua.c32" ] && \
         [ "$file_basename" != "liblua.c32" ] && \
         [[ "$file_basename" != *test.c32 ]] ; then
        copy_file_logged "${BUILD_OUTPUT}"/boot/isolinux/"$file_basename" "${CHROOT_OUTPUT}" /usr/lib/syslinux/modules/bios/"$file_basename"
      fi
    done

    # *always* copy files to output directory so the variables
    # get adjusted according to the build.
    cp "${TEMPLATE_DIRECTORY}"/boot/isolinux/* "${BUILD_OUTPUT}"/boot/isolinux/

    # only for syslinux hdt.
    copy_file_logged "${BUILD_OUTPUT}"/boot/addons/pci.ids "${CHROOT_OUTPUT}" /usr/share/misc/pci.ids
  fi

  mkdir -p "${BUILD_OUTPUT}/boot/grub"
  cp -a "${TEMPLATE_DIRECTORY}"/boot/grub/* "$BUILD_OUTPUT"/boot/grub/

  if [ -n "$NO_ADDONS" ] ; then
    rm -f "$BUILD_OUTPUT"/boot/grub/addons.cfg
    log   "Skipping installation of boot addons as \$NO_ADDONS=${NO_ADDONS}."
    einfo "Skipping installation of boot addons as \$NO_ADDONS=${NO_ADDONS}."; eend 0
  else
    log   "Installing boot addons."
    einfo "Installing boot addons."

    # copy from chroot-installed packages

    # ipxe >= 1.21.1+git20220113.fbbdc3926+dfsg-3
    if [[ "$ARCH" == "amd64" ]] ; then
      copy_file_logged "${BUILD_OUTPUT}"/boot/addons/ipxe.lkrn "${CHROOT_OUTPUT}" /usr/lib/ipxe/ipxe.lkrn
      copy_file_logged "${BUILD_OUTPUT}"/boot/addons/ipxe.efi "${CHROOT_OUTPUT}" /usr/lib/ipxe/ipxe-amd64.efi
    elif [[ "$ARCH" == "arm64" ]] ; then
      copy_file_logged "${BUILD_OUTPUT}"/boot/addons/ipxe.efi "${CHROOT_OUTPUT}" /usr/lib/ipxe/ipxe-arm64.efi
    fi

    # memtest86+ >=6.00-1
    if [[ "$ARCH" == "amd64" ]] ; then
      copy_file_logged "${BUILD_OUTPUT}"/boot/addons/memtest86+x64.efi "${CHROOT_OUTPUT}" /boot/memtest86+x64.efi
    elif [[ "$ARCH" == "i386" ]] ; then
      copy_file_logged "${BUILD_OUTPUT}"/boot/addons/memtest86+ia32.efi "${CHROOT_OUTPUT}" /boot/memtest86+ia32.efi
    fi

    # provide memtest86+ >=6.00-1 files as "memtest" file
    # for BIOS boot in isolinux/syslinux
    if ! [ -r "${BUILD_OUTPUT}/boot/addons/memtest" ] ; then
      if [[ "$ARCH" == "amd64" ]] ; then
        copy_file_logged "${BUILD_OUTPUT}"/boot/addons/memtest "${CHROOT_OUTPUT}" /boot/memtest86+x64.bin
      elif [[ "$ARCH" == "i386" ]] ; then
        copy_file_logged "${BUILD_OUTPUT}"/boot/addons/memtest "${CHROOT_OUTPUT}" /boot/memtest86+ia32.bin
      fi
    fi

    # fallback: if we still don't have /boot/addons/memtest available, we
    # might have an older memtest86+ version (<=5.01-3.1) which ships
    # file "memtest86+.bin" instead
    if ! [ -r "${BUILD_OUTPUT}/boot/addons/memtest" ] ; then
      copy_file_logged "${BUILD_OUTPUT}"/boot/addons/memtest "${CHROOT_OUTPUT}" /boot/memtest86+.bin
    fi

    # copy only files and report which ones are installed
    if [ -d "${TEMPLATE_DIRECTORY}/arch/${ARCH}/boot/addons" ] ; then
      for file in "${TEMPLATE_DIRECTORY}/arch/${ARCH}/boot/addons/"* ; do
        if [ -f "$file" ] ; then
          log   "Installing $file in /boot/addons."
          einfo "Installing $file in /boot/addons."; eend 0
          cp "$file" "$BUILD_OUTPUT"/boot/addons/
        fi
      done
    else # legacy path (before https://github.com/grml/grml-live-grml/pull/11):
      for file in "${TEMPLATE_DIRECTORY}"/boot/addons/* ; do
        if [ -f "$file" ] ; then
          log   "Installing $file in /boot/addons. (Legacy support)"
          einfo "Installing $file in /boot/addons. (Legacy support)"; eend 0
          cp "$file" "$BUILD_OUTPUT"/boot/addons/
        fi
      done
    fi
    eend 0

  fi # NO_ADDONS

  # generate loopback.cfg config file without depending on grub's regexp module
  # which isn't available in Debian/squeeze
  echo "## grub2 loopback configuration" > "${BUILD_OUTPUT}"/boot/grub/loopback.cfg
  echo "source /boot/grub/header.cfg" >> "${BUILD_OUTPUT}"/boot/grub/loopback.cfg
  for config in "${BUILD_OUTPUT}"/boot/grub/*_default.cfg "${BUILD_OUTPUT}"/boot/grub/*_options.cfg ; do
    [ -r "$config" ] || continue
    echo "source ${config##"$BUILD_OUTPUT"}" >> "${BUILD_OUTPUT}"/boot/grub/loopback.cfg
  done
  if [ -z "$NO_ADDONS" ] ; then
    echo "source /boot/grub/addons.cfg" >> "${BUILD_OUTPUT}"/boot/grub/loopback.cfg
  fi
  echo "source /boot/grub/footer.cfg" >> "${BUILD_OUTPUT}"/boot/grub/loopback.cfg

  # copy modules for GRUB
  if [ "${ARCH}" = "arm64" ] ; then
    mkdir -p "${BUILD_OUTPUT}"/boot/grub/arm64-efi/
    cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/arm64-efi/*.mod "${BUILD_OUTPUT}"/boot/grub/arm64-efi/
    cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/arm64-efi/*.lst "${BUILD_OUTPUT}"/boot/grub/arm64-efi/
  elif [ "${ARCH}" = "amd64" ] || [ "${ARCH}" = "i386" ] ; then
    # grub-pc-bin
    mkdir -p "${BUILD_OUTPUT}"/boot/grub/i386-pc/
    cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/*-pc/*.mod  "${BUILD_OUTPUT}"/boot/grub/i386-pc/
    cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/*-pc/*.o    "${BUILD_OUTPUT}"/boot/grub/i386-pc/
    cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/*-pc/*.lst  "${BUILD_OUTPUT}"/boot/grub/i386-pc/

    # grub-efi-amd64-bin
    mkdir -p "${BUILD_OUTPUT}"/boot/grub/x86_64-efi/
    cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/x86_64-efi/*.{mod,lst} "${BUILD_OUTPUT}"/boot/grub/x86_64-efi/

    # grub-efi-ia32-bin
    mkdir -p "${BUILD_OUTPUT}"/boot/grub/i386-efi/
    cp -a "${CHROOT_OUTPUT}"/usr/lib/grub/i386-efi/*.{mod,lst} "${BUILD_OUTPUT}"/boot/grub/i386-efi/
  fi

  # arch independent files
  cp -a "${CHROOT_OUTPUT}"/usr/share/grub/unicode.pf2   "${BUILD_OUTPUT}"/boot/grub/

  if ! [ -d "${TEMPLATE_DIRECTORY}"/GRML ] ; then
    log    "Error: ${TEMPLATE_DIRECTORY}/GRML does not exist. Exiting."
    eerror "Error: ${TEMPLATE_DIRECTORY}/GRML does not exist. Exiting." ; eend 1
    bailout 9
  fi

  mkdir -p "$BUILD_OUTPUT"/GRML/"${GRML_NAME}"/
  cp -a "${TEMPLATE_DIRECTORY}"/GRML/* "$BUILD_OUTPUT"/GRML/"${GRML_NAME}"/

  if [ -r "$BUILD_OUTPUT"/GRML/"${GRML_NAME}"/grml-version ] ; then
    sed -i "s/%RELEASE_INFO%/$RELEASE_INFO/" "$BUILD_OUTPUT"/GRML/"${GRML_NAME}"/grml-version
    sed -i "s/%DATE%/$DATE/"                 "$BUILD_OUTPUT"/GRML/"${GRML_NAME}"/grml-version
  fi

  # make sure the squashfs filename is set accordingly:
  SQUASHFS_NAME="$GRML_NAME.squashfs"

  # add encpasswd to bootoptions
  DEFAULTPW=$(echo ${DEFAULT_BOOTOPTIONS} | grep -Po 'encpasswd=\K[^ ]+' | sed -e 's/^/encpasswd=/g')
  GRUBPW=$(echo ${DEFAULT_BOOTOPTIONS} | grep -Po 'encpasswd=\K[^ ]+' | sed -e 's/\$/\\\\$/g' | sed -e 's/^/encpasswd=/g')
  for config in "${BUILD_OUTPUT}"/boot/grub/"${SHORT_NAME}"_default.cfg "${BUILD_OUTPUT}"/boot/grub/"${SHORT_NAME}"_options.cfg ; do
      sed -i 's,'"${DEFAULTPW}"','"${GRUBPW}"',g' $config
  done

  # adjust bootsplash accordingly but make sure the string has the according length
  fixed_squashfs_name="$(cut_string 20 "$SQUASHFS_NAME")"
  fixed_squashfs_name="$(extend_string_end 20 "$fixed_squashfs_name")"
  for file in f4 f5 ; do
    if [ -r "${BUILD_OUTPUT}/boot/isolinux/${file}" ] ; then
      sed -i "s/%SQUASHFS_NAME%/${fixed_squashfs_name}/" "${BUILD_OUTPUT}/boot/isolinux/${file}"
      sed -i "s/%SQUASHFS_NAME%/${fixed_squashfs_name}/" "${BUILD_OUTPUT}/boot/isolinux/${file}"
    fi
  done

  # adjust all variables in the templates with the according distribution information
  adjust_boot_files "${BUILD_OUTPUT}"/boot/isolinux/*.cfg \
    "${BUILD_OUTPUT}"/boot/isolinux/*.msg \
    "${BUILD_OUTPUT}"/boot/grub/*

  for param in ARCH DATE DISTRI_INFO DISTRI_NAME DISTRI_SPLASH GRML_NAME SQUASHFS_NAME \
    RELEASE_INFO SHORT_NAME VERSION ; do
    while IFS= read -r -d '' file ; do
      value=$(eval echo '$'"$param")
      mv "${file}" "${file/\%${param}\%/$value}"
    done < <(find "${BUILD_OUTPUT}" -name "*%$param%*" -print0)
  done

  if [ "${ARCH}" = "amd64" ] || [ "${ARCH}" = "i386" ] ; then
    # generate isolinux addon list
    ADDONS_LIST_FILE='/boot/isolinux/addons_list.cfg'
    rm -f "${BUILD_OUTPUT}/${ADDONS_LIST_FILE}"
    for name in "${BUILD_OUTPUT}"/boot/isolinux/addon_*.cfg ; do
      include_name=$(basename "$name")
      echo "include $include_name"  >> "${BUILD_OUTPUT}/${ADDONS_LIST_FILE}"
    done

    if ! [ -r "${BUILD_OUTPUT}/boot/isolinux/${DISTRI_NAME}.cfg" ] || [ "$DISTRI_NAME" = "grml" ] ; then
      log "including grmlmain.cfg in ${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
      echo "include grmlmain.cfg"    >  "${BUILD_OUTPUT}/boot/isolinux/distri.cfg"

      # Generate grmlmain.cfg
      {
        echo "include default.cfg"
        echo "include menuoptions.cfg"
        echo "include grml.cfg"
        for f in "${BUILD_OUTPUT}"/boot/isolinux/submenu*.cfg ; do
          echo "include $(basename "$f")"
        done
        echo "include options.cfg"
        if [ -z "$NO_ADDONS" ] ; then
          echo "include addons.cfg"
        fi
        echo "include isoprompt.cfg"
        echo "include hd.cfg"
        echo "include hidden.cfg"
      } > "${BUILD_OUTPUT}/boot/isolinux/grmlmain.cfg"
    else # assume we are building a custom distribution:
      log "File ${BUILD_OUTPUT}/boot/isolinux/${DISTRI_NAME}.cfg found, using it."
      einfo "File ${BUILD_OUTPUT}/boot/isolinux/${DISTRI_NAME}.cfg found, using it."
      if grep -q "^include ${DISTRI_NAME}.cfg" "${BUILD_OUTPUT}/boot/isolinux/distri.cfg" ; then
        log "include for ${DISTRI_NAME}.cfg already present, nothing to do."
        eindent
        einfo "include for ${DISTRI_NAME}.cfg already present, nothing to do."
        eoutdent
        eend $?
      else
        log "including ${DISTRI_NAME}.cfg in ${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
        echo "include ${DISTRI_NAME}.cfg" > "${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
        if [ -z "$NO_ADDONS" ] ; then
          echo "include addons.cfg" >> "${BUILD_OUTPUT}/boot/isolinux/distri.cfg"
        fi
      fi
    fi

    # use old style console based isolinux method only if requested:
    if [[ "${ISOLINUX_METHOD}" == "console" ]] ; then
      log "Using console based isolinux method as requested via \$ISOLINUX_METHOD."
      einfo "Using console based isolinux method as requested via \$ISOLINUX_METHOD."
      if grep -q '^include console.cfg' "${BUILD_OUTPUT}/boot/isolinux/distri.cfg" ; then
        einfo "include for console.cfg already found, nothing to do."
        eend 0
      else
        log "including console.cfg in ${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
        einfo "including console.cfg in ${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
        echo "include console.cfg" >> "${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
        eend 0
      fi
    else
      log 'Using graphical boot menu.'
      if grep -q '^include vesamenu.cfg' "${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg" ; then
        log "include for vesamenu.cfg already found, nothing to do."
      else
        log "including vesamenu.cfg in ${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
        echo "include vesamenu.cfg" >> "${BUILD_OUTPUT}/boot/isolinux/isolinux.cfg"
      fi
    fi
  fi # amd64 or i386

  # the dpkg --list output of the chroot
  DPKG_LIST=$LOG_OUTPUT/fai/dpkg.list
  if ! [ -r "$DPKG_LIST" ] ; then
    ewarn "$DPKG_LIST could not be read, ignoring to store package information on ISO therefore."
  else
    einfo "Storing package list information as /GRML/${GRML_NAME}/packages.txt on ISO."
    cp "$DPKG_LIST" "${BUILD_OUTPUT}"/GRML/"${GRML_NAME}"/packages.txt
    eend $?
  fi

  # autostart for Windows:
  if [ -d "${TEMPLATE_DIRECTORY}/windows/autostart/" ] ; then
    cp "${TEMPLATE_DIRECTORY}"/windows/autostart/* "$BUILD_OUTPUT"/
  fi

  FORCE_ISO_REBUILD=true
  einfo "Finished execution of stage 'boot'" ; eend 0
fi # BOOTSTRAP_ONLY

# support installation of local files into the chroot/ISO
if [ -n "$CHROOT_INSTALL" ] ; then
  if ! [ -d "$CHROOT_INSTALL" ] ; then
     log "Configuration variable \$CHROOT_INSTALL is set but not a directory; ignoring"
     ewarn "Configuration variable \$CHROOT_INSTALL is set but not a directory; ignoring"
  else
     log "Copying local files to chroot as requested via \$CHROOT_INSTALL"
     einfo "Copying local files to chroot as requested via \$CHROOT_INSTALL"
     rsync -avz --inplace "$CHROOT_INSTALL"/ "$CHROOT_OUTPUT/"
     eend $?
     einfo "Make sure to run squashfs stage, otherwise your local files won't be part of the ISO."
     FORCE_ISO_REBUILD=true
  fi
fi

if [ -f "$BUILD_OUTPUT"/live/"${GRML_NAME}".squashfs ] && [ -z "$UPDATE" ] && [ -z "$BUILD_ONLY" ] && [ -z "$BUILD_DIRTY" ] ; then
   log   "Skipping stage 'squashfs' as $BUILD_OUTPUT/live exists already."
   ewarn "Skipping stage 'squashfs' as $BUILD_OUTPUT/live exists already." ; eend 0
elif [ -n "$SKIP_MKSQUASHFS" ] ; then
   log   "Skipping stage 'squashfs' as requested via option -q or -N"
   ewarn "Skipping stage 'squashfs' as requested via option -q or -N" ; eend 0
else
   mkdir -p "$BUILD_OUTPUT"/live/"${GRML_NAME}"/
   # make sure we don't leave (even an empty) base.tgz:
   [ -f "$CHROOT_OUTPUT/base.tgz" ] && rm -f "$CHROOT_OUTPUT/base.tgz"

   if which "$SQUASHFS_BINARY" >/dev/null 2>&1 ; then
      log    "Using mksquashfs binary ${SQUASHFS_BINARY}"
      einfo  "Using mksquashfs binary ${SQUASHFS_BINARY}" ; eend 0
   else
      log    "Error: mksquashfs binary ($SQUASHFS_BINARY) not found. Exiting."
      eerror "Error: mksquashfs binary ($SQUASHFS_BINARY) not found. Exiting." ; eend 1
      bailout
   fi

   # use sane defaults if $SQUASHFS_OPTIONS isn't set
   if [ -z "$SQUASHFS_OPTIONS" ] ; then
     # use block size 1m as this gives good result with regards to time + compression
     SQUASHFS_OPTIONS="-b 1m"

     # set lzma/xz compression by default, unless -z option has been specified on command line
     if [ -z "$SQUASHFS_ZLIB" ] ; then
        SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -comp xz"
     else
        SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -comp gzip"
     fi
   fi

   # Ignore all extended attributes. This avoids:
   # 1) leaking containerization supplied selinux attributes into the squashfs,
   # 2) prevents unpacking errors in a later build-only step in containers not supporting xattrs.
   SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -no-xattrs"

   # support exclusion of files via exclude-file:
   if [ -n "$SQUASHFS_EXCLUDES_FILE" ] && [ "$SQUASHFS_EXCLUDES_FILE" ] ; then
      SQUASHFS_OPTIONS="$SQUASHFS_OPTIONS -ef $SQUASHFS_EXCLUDES_FILE -wildcards"
   fi

   # log stuff
   SQUASHFS_STDERR="$(mktemp -t grml-live.XXXXXX)"

   # informational stuff
   [ -n "$SQUASHFS_OPTIONS" ]  && SQUASHFS_INFO_MSG="$SQUASHFS_OPTIONS"
   [ -n "$SQUASHFS_INFO_MSG" ] && SQUASHFS_INFO_MSG="using options: $SQUASHFS_INFO_MSG"
   einfo "Squashfs build information: running binary $SQUASHFS_BINARY $SQUASHFS_INFO_MSG"

   log "$SQUASHFS_BINARY $CHROOT_OUTPUT/ $BUILD_OUTPUT/live/${GRML_NAME}/${GRML_NAME}.squashfs -noappend $SQUASHFS_OPTIONS"
   # shellcheck disable=SC2086 # $SQUASHFS_OPTIONS needs splitting
   if "$SQUASHFS_BINARY" "$CHROOT_OUTPUT/" "$BUILD_OUTPUT"/live/"${GRML_NAME}"/"${GRML_NAME}".squashfs \
      -noappend $SQUASHFS_OPTIONS 2>"${SQUASHFS_STDERR}" ; then
      echo "${GRML_NAME}.squashfs" > "$BUILD_OUTPUT"/live/"${GRML_NAME}"/filesystem.module
      log "Finished execution of stage 'squashfs' [$(date)]"
      einfo "Finished execution of stage 'squashfs'" ; eend 0
   else
      log    "Error: there was a critical error executing stage 'squashfs' [$(date)]:"
      log    "$(cat "$SQUASHFS_STDERR")"
      eerror "Error: there was a critical error executing stage 'squashfs':"
      cat    "${SQUASHFS_STDERR}"
      eend 1
      bailout
   fi

   FORCE_ISO_REBUILD=true
fi

# create md5sum file:
if [ -z "$BOOTSTRAP_ONLY" ] ; then
  # shellcheck disable=SC2094 # find execution ignores written file
  ( cd "$BUILD_OUTPUT"/GRML/"${GRML_NAME}" &&
  find ../.. -type f -not -name md5sums -not -name isolinux.bin -exec md5sum {} \; > md5sums )
fi
# }}}

# information how the ISO was generated {{{
# shellcheck disable=SC2034
generate_build_info() {
  jo -p \
    bootstrap_only="${BOOTSTRAP_ONLY}" \
    build_date="${DATE}" \
    build_dirty="${BUILD_DIRTY}" \
    build_only="${BUILD_ONLY}" \
    chroot_install="${CHROOT_INSTALL}" \
    classes="${CLASSES}" \
    clean_artifacts="${CLEAN_ARTIFACTS}" \
    default_bootoptions="${DEFAULT_BOOTOPTIONS}" \
    distri_info="${DISTRI_INFO}" \
    distri_name="${DISTRI_NAME}" \
    extract_iso_name="${EXTRACT_ISO_NAME}" \
    fai_cmdline="${FAI_PROGRAM} ${GRML_FAI_CONFIG} ${CLASSES} ${FAI_ACTION} ${CHROOT_OUTPUT} ${CONFIGDUMP} ${FAI_DEBOOTSTRAP}" \
    fai_version="minifai" \
    grml_architecture="${ARCH}" \
    grml_bootid="${BOOTID}" \
    grml_build_output="${BUILD_OUTPUT}" \
    grml_chroot_output="${CHROOT_OUTPUT}" \
    grml_debian_version="${SUITE}" \
    grml_iso_name="${ISO_NAME}" \
    grml_iso_output="${ISO_OUTPUT}" \
    grml_live_cmdline="${CMDLINE}" \
    grml_live_config_file="${LIVE_CONF}" \
    grml_live_scripts_directory="${SCRIPTS_DIRECTORY}" \
    grml_live_template_directory="${TEMPLATE_DIRECTORY}" \
    grml_live_version="${GRML_LIVE_VERSION}" \
    grml_local_config="${LOCAL_CONFIG}" \
    grml_name="${GRML_NAME}" \
    grml_short_name="${SHORT_NAME}" \
    grml_username="${USERNAME}" \
    grml_version="${VERSION}" \
    host_architecture="$(dpkg --print-architecture || true)" \
    host_debian_version="$(cat /etc/debian_version 2>/dev/null || true)" \
    host_kernel_version="$(uname -a)" \
    hybrid_method="${HYBRID_METHOD}" \
    mkisofs_cmdline="${MKISOFS} -V ${GRML_NAME} ${VERSION} -publisher 'grml-live | grml.org' -l -r -J ${BOOT_ARGS} ${EFI_ARGS} -no-pad -o ${ISO_OUTPUT}/${ISO_NAME}" \
    mkisofs_version="$(${MKISOFS} --version 2>/dev/null | head -1 || true)" \
    mksquashfs_cmdline="${SQUASHFS_BINARY} ${CHROOT_OUTPUT}/ ${BUILD_OUTPUT}/live/${GRML_NAME}/${GRML_NAME}.squashfs -noappend ${SQUASHFS_OPTIONS}" \
    mksquashfs_version="$(${SQUASHFS_BINARY} -version | head -1 || true)" \
    output_owner="${CHOWN_USER}" \
    release_info="${RELEASE_INFO}" \
    release_name="${RELEASENAME}" \
    secure_boot="${SECURE_BOOT}" \
    skip_mkisofs="${SKIP_MKISOFS}" \
    skip_mksquashfs_="${SKIP_MKSQUASHFS}" \
    skip_netboot="${SKIP_NETBOOT}" \
    squashfs_name="${SQUASHFS_NAME}" \
    template_directory="${TEMPLATE_DIRECTORY}" \
    timestamp="$(TZ=UTC date +%s)" \
    update_only="${UPDATE}" \
    wayback_date="${WAYBACK_DATE}" \
  --
}
# }}}

# ISO_OUTPUT - mkisofs {{{
[ -n "$ISO_OUTPUT" ] || ISO_OUTPUT="$OUTPUT/grml_isos"
[ -n "$ISO_NAME" ] || ISO_NAME="${GRML_NAME}_${VERSION}.iso"

BOOT_ARGS="-no-emul-boot -boot-load-size 4 -boot-info-table -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat"
if [ "$HYBRID_METHOD" = "isohybrid" ] ; then
  EFI_ARGS="-isohybrid-mbr ${CHROOT_OUTPUT}/usr/lib/ISOLINUX/isohdpfx.bin -eltorito-alt-boot -e boot/efi.img -no-emul-boot -isohybrid-gpt-basdat"
fi
if [ "$ARCH" = "arm64" ]; then
  # No isolinux on arm64.
  BOOT_ARGS=""
  EFI_ARGS="-eltorito-alt-boot -e boot/efi.img -no-emul-boot -isohybrid-gpt-basdat"
fi

if [ -f "${ISO_OUTPUT}/${ISO_NAME}" ] && [ -z "$UPDATE" ] && [ -z "$BUILD_ONLY" ] && [ -z "$BUILD_DIRTY" ] && [ "$FORCE_ISO_REBUILD" = "false" ]  ; then
   log   "Skipping stage 'iso build' as $ISO_OUTPUT/${ISO_NAME} exists already."
   ewarn "Skipping stage 'iso build' as $ISO_OUTPUT/${ISO_NAME} exists already." ; eend 0
elif [ -n "$SKIP_MKISOFS" ] ; then
   log   "Skipping stage 'iso build' as requested via option -n or -N"
   ewarn "Skipping stage 'iso build' as requested via option -n or -N" ; eend 0
else
   mkdir -p "$ISO_OUTPUT" || bailout 6 "Problem with creating $ISO_OUTPUT for stage 'iso build'"

   if "$FORCE_ISO_REBUILD" && ! [ -f "${ISO_OUTPUT}/${ISO_NAME}" ] ; then
      log   "Forcing rebuild of ISO because files on ISO have been modified."
      einfo "Forcing rebuild of ISO because files on ISO have been modified."
   fi

   if which xorriso >/dev/null 2>&1 ; then
      MKISOFS='xorriso -as mkisofs'
   else
      log    "Error: xorriso not available - can not create ISO."
      eerror "Error: xorriso not available - can not create ISO." ; eend 1
      bailout
   fi

   einfo "Using ${MKISOFS} to build ISO." ;  eend 0
   case "${ARCH}" in
     # using -eltorito-alt-boot is limited to xorriso for now
     amd64)
       eindent

       if [ -r "${BUILD_OUTPUT}"/boot/efi.img ] ; then
         einfo "Enabling (U)EFI boot."
         log   "Enabling (U)EFI boot."
         BOOT_ARGS="$BOOT_ARGS -boot-info-table -eltorito-alt-boot -e boot/efi.img -no-emul-boot"
         eend $?
       else
         log   "Disabling (U)EFI boot support because /boot/efi.img is missing."
         ewarn "Disabling (U)EFI boot support because /boot/efi.img is missing." ; eend 0
       fi

       eoutdent
       ;;
   esac

   log   "Generating build information in conf/buildinfo.json"
   einfo "Generating build information in conf/buildinfo.json"
   mkdir -p "$BUILD_OUTPUT"/conf/
   generate_build_info > "$BUILD_OUTPUT"/conf/buildinfo.json
   eend $?

   log "$MKISOFS -V '${GRML_NAME} ${VERSION}' -publisher 'grml-live | grml.org' -l -r -J $BOOT_ARGS $EFI_ARGS -no-pad -o ${ISO_OUTPUT}/${ISO_NAME} ."
   einfo "Generating ISO file..."
   # shellcheck disable=SC2086 # BOOT_ARGS and EFI_ARGS need splitting
   $MKISOFS -V "${GRML_NAME} ${VERSION}" -publisher 'grml-live | grml.org' \
           -l -r -J $BOOT_ARGS $EFI_ARGS -no-pad \
           -o "${ISO_OUTPUT}/${ISO_NAME}" "$BUILD_OUTPUT"/ ; RC=$?
   eend $RC

   # do not continue on errors, otherwise we might generate/overwrite the ISO with dd if=... stuff
   if [ "$RC" != 0 ] ; then
     log    "Error: critical error while generating ISO [exit code ${RC}]. Exiting."
     eerror "Error: critical error while generating ISO [exit code ${RC}]. Exiting." ; eend 1
     bailout "$RC"
   fi

   # pad the output ISO to multiples of 256 KiB for partition table support
   siz=$($getfilesize "${ISO_OUTPUT}/${ISO_NAME}")
   cyls=$((siz / 512 / 32 / 16 + 1))   # C=$cyls H=16 S=32
   siz=$((cyls * 16 * 32 * 512))   # size after padding
   dd if=/dev/zero bs=1 count=1 seek=$((siz - 1)) \
      of="${ISO_OUTPUT}/${ISO_NAME}" 2>/dev/null

   # generate ISO checksums if we are using class 'RELEASE':
   if hasclass RELEASE && [ "$RC" = 0 ] ; then
      (
        if cd "$ISO_OUTPUT" ; then
          sha256sum "${ISO_NAME}" > "${ISO_NAME}.sha256" && \
          touch -r "${ISO_NAME}" "${ISO_NAME}.sha256"
        fi
      )
   fi

   if [ "$RC" = 0 ] ; then
      log   "Finished execution of stage 'iso build' [$(date)]"
      einfo "Finished execution of stage 'iso build'" ; eend 0
   else
      log    "Error: there was a critical error ($RC) executing stage 'iso build' [$(date)]"
      eerror "Error: there was a critical error executing stage 'iso build'" ; eend 1
      bailout "$RC"
   fi
fi
# }}}

# netboot package {{{
create_netbootpackage() {
  local OUTPUT_NAME
  local OUTPUT_FILE
  OUTPUT_NAME=$(basename "${ISO_NAME}" .iso)-netboot
  OUTPUT_FILE="${NETBOOT}/${OUTPUT_NAME}.tar"

  if [ -f "${OUTPUT_FILE}" ] && [ -z "$UPDATE" ] && [ -z "$BUILD_ONLY" ] && [ -z "$BUILD_DIRTY" ] ; then
    log   "Skipping stage 'netboot' as $OUTPUT_FILE exists already."
    ewarn "Skipping stage 'netboot' as $OUTPUT_FILE exists already." ; eend 0
    return 0
  elif [ -n "$SKIP_NETBOOT" ] ; then
    log   "Skipping stage 'netboot' as requested via option -Q"
    ewarn "Skipping stage 'netboot' as requested via option -Q" ; eend 0
    return 0
  fi

  mkdir -p "$NETBOOT"

  local OUTPUTDIR="${NETBOOT}/build_tmp"
  local WORKING_DIR="${OUTPUTDIR}/${OUTPUT_NAME}/tftpboot/"

  mkdir -p "$WORKING_DIR"

  cp "${CHROOT_OUTPUT}"/boot/vmlinuz-*    "$WORKING_DIR"/vmlinuz
  cp "${CHROOT_OUTPUT}"/boot/initrd.img-* "$WORKING_DIR"/initrd.img

  if [ "$ARCH" = "amd64" ] || [ "$ARCH" = "i386" ] ; then
    if ! [ -r "${CHROOT_OUTPUT}/usr/lib/PXELINUX/pxelinux.0" ] ; then
      ewarn "File /usr/lib/PXELINUX/pxelinux.0 not found in build chroot." ; eend 0
      eindent
      einfo "Install syslinux[-common]/pxelinux package in chroot to get a netboot package."
      eoutdent
      return 0
    fi

    cp "${CHROOT_OUTPUT}/usr/lib/PXELINUX/pxelinux.0" "${WORKING_DIR}/pxelinux.0"

    if [ -r "${CHROOT_OUTPUT}"/usr/lib/syslinux/modules/bios/ldlinux.c32 ] ; then
      cp "${CHROOT_OUTPUT}"/usr/lib/syslinux/modules/bios/ldlinux.c32 "${WORKING_DIR}"/
    fi

    mkdir -p "${WORKING_DIR}/pxelinux.cfg"
    if [ -r "${BUILD_OUTPUT}/boot/isolinux/netboot.cfg" ] ; then
      cp "${BUILD_OUTPUT}/boot/isolinux/netboot.cfg" "${WORKING_DIR}/pxelinux.cfg/default"
    else
      log   "File ${BUILD_OUTPUT}/boot/isolinux/netboot.cfg not found."
      ewarn "File ${BUILD_OUTPUT}/boot/isolinux/netboot.cfg not found."
      eindent
      log   "Hint: Are you using custom templates which do not provide netboot.cfg?"
      ewarn "Hint: Are you using custom templates which do not provide netboot.cfg?" ; eend 0
      eoutdent
    fi
  fi # amd64 or i386

  # don't include shim + grubnetx64 + grub files in i386 netboot packages,
  # as those don't make much sense there
  if [ "$ARCH" = "amd64" ] || [ "$ARCH" = "arm64" ] ; then
    if ! [ -r "${BUILD_OUTPUT}/boot/grub/netboot.cfg" ] ; then
      log   "File ${BUILD_OUTPUT}/boot/grub/netboot.cfg not found."
      ewarn "File ${BUILD_OUTPUT}/boot/grub/netboot.cfg not found."
      eindent
      log   "Hint: Are you using custom templates which do not provide netboot.cfg?"
      ewarn "Hint: Are you using custom templates which do not provide netboot.cfg?" ; eend 0
      eoutdent
    else
      cp "${BUILD_OUTPUT}/boot/grub/netboot.cfg" "${WORKING_DIR}/grub.cfg"
      adjust_boot_files "${WORKING_DIR}/grub.cfg"

      if [ "$ARCH" = "amd64" ] ; then
        if ! copy_file_logged "${WORKING_DIR}"/shim.efi "${CHROOT_OUTPUT}" \
          /usr/lib/shim/shimx64.efi.signed \
          /usr/lib/shim/shimx64.efi
        then
          log   "No shimx64.efi for usage with PXE boot found (shim-signed not present?)"
          ewarn "No shimx64.efi for usage with PXE boot found (shim-signed not present?)" ; eend 0
        fi

        if ! copy_file_logged "${WORKING_DIR}"/grubx64.efi "${CHROOT_OUTPUT}" \
          /usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed \
          /usr/lib/grub/x86_64-efi/monolithic/grubnetx64.efi
        then
          log   "No grubnetx64.efi for usage with PXE boot found (grub-efi-amd64-signed not present?)"
          ewarn "No grubnetx64.efi for usage with PXE boot found (grub-efi-amd64-signed not present?)." ; eend 0
        fi

        # UEFI 32bit boot
        if ! copy_file_logged "${WORKING_DIR}"/grubia32.efi "${CHROOT_OUTPUT}" \
          /usr/lib/grub/i386-efi-signed/grubnetia32.efi.signed \
          /usr/lib/grub/i386-efi/monolithic/grubnetia32.efi
        then
          log   "No grubnetia32.efi for usage with PXE boot found (grub-efi-ia32-unsigned present?)"
          ewarn "No grubnetia32.efi for usage with PXE boot found (grub-efi-ia32-unsigned present?)." ; eend 0
        fi
      fi

      if [ "$ARCH" = "arm64" ] ; then
        if ! copy_file_logged "${WORKING_DIR}"/shim.efi "${CHROOT_OUTPUT}" \
          /usr/lib/shim/shimaa64.efi.signed \
          /usr/lib/shim/shimaa64.efi
        then
          log   "No shimaa64.efi for usage with PXE boot found (shim-signed not present?)"
          ewarn "No shimaa64.efi for usage with PXE boot found (shim-signed not present?)" ; eend 0
        fi

        if ! copy_file_logged "${WORKING_DIR}"/grubaa64.efi "${CHROOT_OUTPUT}" \
          /usr/lib/grub/arm64-efi-signed/grubnetaa64.efi.signed \
          /usr/lib/grub/arm64-efi/monolithic/grubnetaa64.efi
        then
          log   "No grubnetaa64.efi for usage with PXE boot found (grub-efi-arm64-signed not present?)"
          ewarn "No grubnetaa64.efi for usage with PXE boot found (grub-efi-arm64-signed not present?)." ; eend 0
        fi
      fi

      if [ -r "${CHROOT_OUTPUT}"/usr/share/grub/unicode.pf2 ] ; then
        log "Installing ${CHROOT_OUTPUT}/usr/share/grub/unicode.pf2 as grub/fonts/unicode.pf2 in netboot package"
        mkdir -p "${WORKING_DIR}"/grub/fonts/
        cp "${CHROOT_OUTPUT}"/usr/share/grub/unicode.pf2 "${WORKING_DIR}"/grub/fonts/
      else
        log   "No unicode.pf2 for usage with PXE boot found (grub-common not present?)"
        ewarn "No unicode.pf2 for usage with PXE boot found (grub-common not present?)" ; eend 0
      fi
    fi
  fi # amd64 or arm64

  if tar -C "$OUTPUTDIR" -cf "${OUTPUT_FILE}" "${OUTPUT_NAME}" ; then
    (
      # shellcheck disable=SC2164 # We just wrote there. If it disappeared, too bad.
      cd "$(dirname "${OUTPUT_FILE}")"
      sha256sum "$(basename "${OUTPUT_FILE}")" > "${OUTPUT_FILE}.sha256"
    )
    einfo "Generated netboot package ${OUTPUT_FILE}" ; eend 0
    rm -rf "${OUTPUTDIR}"
  else
    rm -rf "${OUTPUTDIR}"
    eerror "Could not generate netboot package ${OUTPUT_FILE}" ; eend 1
    bailout 21
  fi
}

create_netbootpackage
# }}}

# {{{
create_sourcespackages() {
  if ! hasclass SOURCES ; then
    log "Skipping source package generation, only enabled with class SOURCES"
    return 0
  fi

  local OUTPUT_FILE SOURCES_DIR
  OUTPUT_FILE="${OUTPUT}/$(basename "${ISO_NAME}" .iso)-sources.tar"
  SOURCES_DIR="${OUTPUT}/grml_sources/"

  if ! [ -d "${SOURCES_DIR}" ] ; then
    eerror "Base directory ${SOURCES_DIR} not present, can not generate source package" ; eend 1
    bailout 22
  fi

  if tar -C "${OUTPUT}" -cf "${OUTPUT_FILE}" "$(basename "${SOURCES_DIR}")" ; then
   (
     # shellcheck disable=SC2164 # We just wrote there. If it disappeared, too bad.
     cd "$(dirname "${OUTPUT_FILE}")"
     sha256sum "$(basename "${OUTPUT_FILE}")" > "${OUTPUT_FILE}.sha256"
   )
   einfo "Generated source package ${OUTPUT_FILE}" ; eend 0
 else
   eerror "Could not generate source package ${OUTPUT_FILE}" ; eend 1
   bailout 22
 fi
}

create_sourcespackages
# }}}

# finalize {{{
if [ -n "${start_seconds}" ] ; then
  end_seconds="$(date +%s)"
  SECONDS="$(( end_seconds - start_seconds ))"
fi
log "Successfully finished execution of $PN [$(date) - running ${SECONDS} seconds]"

einfo "Successfully finished execution of $PN [$(date) - running ${SECONDS} seconds]" ; eend 0
bailout 0
# }}}

## END OF FILE #################################################################
# vim:foldmethod=marker ts=2 ft=sh ai expandtab tw=80 sw=2
